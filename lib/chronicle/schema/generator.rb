require 'rdf/turtle'
require 'rdf/reasoner'
require 'sparql'
require 'tsort'

module Chronicle::Schema
  class DependencySorter
    include TSort
  
    def initialize(dependencies)
      @dependencies = dependencies
    end
  
    def tsort_each_node(&block)
      @dependencies.each_key(&block)
    end
  
    def tsort_each_child(node, &block)
      @dependencies[node][:dependencies].each(&block) if @dependencies[node]
    end
  end

  class Generator
    OUTPUT_DIRECTORY = File.join(File.dirname(__FILE__), 'types')

    attr_reader :ttl_path

    def initialize(ttl_path)
      @ttl_path = ttl_path
      @graph = load_graph(@ttl_path)
      @properties = gather_global_properties
      RDF::Reasoner.apply(:rdfs, :owl, :schema)
    end

    def load_graph(ttl_path)
      ttl = File.read(ttl_path)
      RDF::Graph.new.from_ttl(ttl)
    end

    def generate!
      # root_uri = RDF::URI.new('https://schema.chronicle.app/Entity')
      # all_classes = all_subclasses(root_uri) << root_uri

      detailed_classes = {}
      all_classes.each do |class_uri|
        detailed_classes[class_uri.to_s] = build_class_details(class_uri)
      end
 
      sorted_classes = DependencySorter.new(detailed_classes).tsort

      schema_code_str = <<~RUBY
# Generated by Chronicle::Schema::Generator
  # from #{@ttl_path}
  #
  # Do not edit directly!
  # To edit, make a change to the schema.ttl file and run `rake schema:generate`
      #
      module Chronicle::Schema::Types
      RUBY

      sorted_classes.each do |class_uri|
        class_details = detailed_classes[class_uri]
        next unless class_details
        puts
        puts "Generating schema for #{class_details[:class_name_short]} with #{class_details[:properties]} properties"
        puts "Properties:\n#{class_details[:properties].join("\n")}"
        puts
        class_schema = generate_ruby_validator(class_details[:class_name_short], class_details[:properties])

        schema_code_str += "#{class_schema}\n"
      end

      schema_code_str += "end\n"
      path = File.join(OUTPUT_DIRECTORY, "types.rb")
        File.open(path, 'w') do |f|
          f.write(schema_code_str)
        end
    end

    private

    def all_classes
      @graph.query([nil, RDF.type, RDF::RDFS.Class]).map(&:subject)
    end

    def build_class_details(class_uri)
      {
        class: class_uri,
        class_name_short: strip_uri(class_uri),
        properties: properties_of_superclasses(class_uri),
        subclasses: all_subclasses(class_uri),
        superclasses: all_superclasses(class_uri),
        dependencies: (nearest_superclass(class_uri).map(&:to_s) + properties_of_superclasses(class_uri).map{|p| p[:range]}.flatten).uniq
      }
    end

    def gather_global_properties
      properties = @graph.query([nil, RDF.type, RDF::RDFV.Property]).map(&:subject)
    

      properties.map do |property|
        range = @graph.query([
          property,
          RDF::URI.new('https://schema.chronicle.app/rangeIncludes'),
          nil]
        ).map(&:object).map(&:to_s)

        {
          name: property.to_s,
          name_snake_case: camel_to_snake(property.to_s.gsub('https://schema.chronicle.app/', '')),
          range: range,
          range_with_subclasses: (range + range.map{|r| all_subclasses(RDF::URI.new(r)).map(&:to_s)}).flatten.uniq,
          domain: @graph.query([
                property,
                RDF::URI.new('https://schema.chronicle.app/domainIncludes'),
                nil]
            ).map(&:object).map(&:to_s),
          cardinality: get_property_cardinality(property)
        }
      end
    end

    def get_property_cardinality(property)
      min_cardinality = @graph.query([
        property,
        RDF::OWL.minCardinality,
        nil]
      ).map(&:object).first&.to_i
      max_cardinality = @graph.query([
        property,
        RDF::OWL.maxCardinality,
        nil
      ]).map(&:object).first&.to_i

      if min_cardinality == 1 && max_cardinality == 1
        return :one
      elsif min_cardinality.nil? && max_cardinality == 1
        return :zero_or_one
      elsif min_cardinality == 1 && max_cardinality.nil?
        return :one_or_more
      elsif min_cardinality.nil? && max_cardinality.nil?
        return :zero_or_more
      end
    end

    def all_subclasses(class_uri, subclasses = [])
      direct_subclasses = @graph.query([nil, RDF::RDFS.subClassOf, class_uri]).map(&:subject)

      direct_subclasses.each do |subclass|
        subclasses << subclass unless subclasses.include?(subclass)
        all_subclasses(subclass, subclasses)
      end

      subclasses
    end

    def nearest_superclass(class_uri)
      @graph.query([class_uri, RDF::RDFS.subClassOf, nil]).map(&:object)
    end

    def all_superclasses(class_uri, superclasses = [])
      direct_superclasses = @graph.query([class_uri, RDF::RDFS.subClassOf, nil]).map(&:object)

      direct_superclasses.each do |superclass|
        superclasses << superclass unless superclasses.include?(superclass)
        all_superclasses(superclass, superclasses)
      end

      superclasses
    end

    def properties_of_class(class_uri)
      @properties.select do |property|
        property[:domain].include?(class_uri.to_s)
      end
    end

    def properties_of_superclasses(class_uri)
      properties = properties_of_class(class_uri)

      # Get properties of the superclasses
      superclasses = all_superclasses(class_uri)
      superclasses.each do |superclass|
        properties.concat(properties_of_class(superclass))
      end

      properties.uniq
    end

    def get_property_range(property_uri)
      @graph.query([
        property_uri,
        RDF::URI.new('https://schema.chronicle.app/rangeIncludes'),
        nil]
      ).map(&:object)
       .map{|o| o.to_s.gsub('https://schema.chronicle.app/', '')}
    end

    def generate_ruby_class(class_name, props)
      prop_strings = props.map do |prop|
        # prop_name = prop.path.gsub(/^\//, '')
        camel_to_snake(prop[:name])
      end

      <<~RUBY
        module Chronicle::Schema::Types
          class #{class_name}
            #{'attr_accessor ' + prop_strings.map{|p| p.prepend(":")}.join(', ') if prop_strings.any?}
          end
        end
      RUBY
    end

    def generate_ruby_validator(class_name, props)
      prop_relationships = props.map do |prop|
        generate_edge(prop)
      end.join("\n")

      <<~RUBY
        #{class_name}Schema = Dry::Schema.Params do
          required(:type).filled(:string, eql?: 'entities')
          required(:attributes).schema do
            required(:represents).filled(:string, eql?: '#{class_name}')
          end
          required(:meta).schema(Chronicle::Schema::Types::Base::DedupeOnSchema)
          required(:relationships).schema do
            #{prop_relationships}
          end
        end
      RUBY
    end

    def generate_edge(property)
      processed_range = property[:range_with_subclasses].map do |range|
        "Chronicle::Schema::Types::#{strip_uri(range)}Schema"
      end.join(' | ')

      case property[:cardinality]
      when :one
        <<~STR
          required(:#{property[:name_snake_case]}).schema do
            required(:data).hash(#{processed_range})
          end
        STR
      when :zero_or_one
        <<~STR
          optional(:#{property[:name_snake_case]}).schema do
            required(:data).hash(#{processed_range})
          end
        STR
      when :one_or_more
        <<~STR
        required(:#{property[:name_snake_case]}).schema do
          required(:data).value(:array).each do
            hash(#{processed_range})
          end
        end
        STR
      when :zero_or_more
        <<~STR
        optional(:#{property[:name_snake_case]}).schema do
          required(:data).value(:array).each do
            hash(#{processed_range})
          end
        end
        STR
      end
    end

    def strip_uri(uri)
      uri.to_s.gsub('https://schema.chronicle.app/', '')
    end

    def camel_to_snake(string)
      string.gsub(/([a-z\d])([A-Z])/, '\1_\2').downcase
    end
  end
end
